<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Offer Decoder</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
</head>
<body>

<div id="app">
    <v-app>
        <div class="square-qubits" :style="{ 'height': square_height + 'px', 'width': square_height + 'px', 'left': square_left + 'px', 'top': square_top + 'px' }"
                @click="select_qubit(null)">
            <div v-for="(row, row_index) of qubits" v-bind:key="row_index" class="qubits-row" :style="{ 'top': (qubit_bias + row_index * qubit_interval) + 'px' }">
                <div v-for="(qubit, index) of row" v-bind:key="index" class="qubits-container"
                        :style="{ 'left': (qubit_bias + index * qubit_interval) + 'px', 'transform': `scale(${qubit_scale})` }">
                    <data-qubit v-if="qubit.qubit_type == CONST.QubitType.Data" v-model="row[index]" @select-qubit="select_qubit"
                        @error-changed="error_changed"></data-qubit>
                    <stabilizer-qubit v-if="qubit.qubit_type != CONST.QubitType.Data" v-model="row[index]" @select-qubit="select_qubit"></stabilizer-qubit>
                </div>
            </div>
        </div>
        <div class="control-panel no-scrollbar">
            <h1>Offer Decoder Testbed</h1>
            <p>Offer Decoder is a fully distributed topological code decoder. Every stabilizer as a decoder unit runs individually and only communicates with neighbors. In bounded time, the whole system converges to a stable state which is the error matching with the highest probability. The key idea is that matched pairs can work as "broker" and associate with unmatched stabilizers to optimize overall probability.</p>
            <p style="color: lightblue;">This page aims at helping us understand how it works and try out different strategies.</p>
            <v-text-field outlined label="Code Distance" type="number" v-model="L_input" :rules="L_input_rules"></v-text-field>
            <div v-if="selecting != null">
                <h2>Selecting {{ `(${selecting[0]}, ${selecting[1]})`}} ({{ selecting[0] + selecting[1] % 2 == 0 ? "data qubit" : "stabilizer" }})</h2>
                <v-card elevation="5" width="440" class="mx-auto">
                    <v-virtual-scroll :items="log_items" :item-height="50" height="500">
                        <template v-slot:default="{ item }">
                            <v-list-item>
                                <v-list-item-avatar>
                                    <v-avatar :color="item.color" size="56" class="white--text">{{ item.initials }}</v-avatar>
                                </v-list-item-avatar>
                                <v-list-item-content>
                                    <v-list-item-title>{{ item.full_message }}</v-list-item-title>
                                </v-list-item-content>
                                <v-list-item-action>
                                    <v-btn depressed small @click="view_log(item)">View<v-icon color="orange darken-4" right>mdi-open-in-new</v-icon></v-btn>
                                </v-list-item-action>
                            </v-list-item>
                        </template>
                    </v-virtual-scroll>
                </v-card>
            </div>
        </div>
    </v-app>
</div>

<template id="data-qubit">
    <div class="qubit-div" :style="{ 'transform': `scale(${qubit.sub_scale})` }">
        <div class="data-qubit-div" :class="{ 'qubit-selected': qubit.selected }" @click="select_self">
            <h1 class="noselect">data</h1>
            <v-btn fab :width="120" :height="120" style="font-size: 100px;" :color="error_color" @click="change_error">{{ error_text }}</v-btn>
        </div>
    </div>
</template>

<template id="stabilizer-qubit">
    <div class="qubit-div" :style="{ 'transform': `scale(${qubit.sub_scale})` }">
        <div :class="{ 'stabilizer-qubit-div-Z': qubit.qubit_type == CONST.QubitType.StabZ, 'stabilizer-qubit-div-X': qubit.qubit_type == CONST.QubitType.StabX, 'qubit-selected': qubit.selected, 'stabilizer-qubit-div-X-no-error': qubit.qubit_type == CONST.QubitType.StabX && !qubit.measurement, 'stabilizer-qubit-div-X-with-error': qubit.qubit_type == CONST.QubitType.StabX && qubit.measurement, 'stabilizer-qubit-div-Z-no-error': qubit.qubit_type == CONST.QubitType.StabZ && !qubit.measurement, 'stabilizer-qubit-div-Z-with-error': qubit.qubit_type == CONST.QubitType.StabZ && qubit.measurement }"
                @click="select_self">
            <h1 class="noselect">{{ qubit.qubit_type == CONST.QubitType.StabZ ? "Z" : "X" }}</h1>
        </div>
    </div>
</template>

<!-- Vue.js -->
<script>

// use this function to restriction modification to constants
function readonly(target, keys) {
    var _cloned = {}
    function makeReadOnlyProperty(cloned, obj, prop) {
        Object.defineProperty(cloned, prop, {
            set: function() {
                throw {
                    name: 'UnableRewriteException',
                    message: 'original cannot be rewrite'
                }
            },
            get: function() {
                return obj[prop]
            },
            enumerable: true
        })
    }
    for (var prop in target) {
        makeReadOnlyProperty(_cloned, target, prop)
    }
    return _cloned
}

const CONST = readonly({
    QubitType: readonly({
        Data: "Data",
        StabZ: "StabZ",
        StabX: "StabX",
    }),
    ErrorType: readonly({
        I: "I",
        X: "X",
        Z: "Z",
        Y: "Y",
    }),
    // display related
    QubitDivWidth: 200,  // px
    QubitWidthRatio: 0.9,
    Colors: readonly({
        I: "#FFFFFF",
        X: "#00CC00",
        Z: "#00BFFF",
        Y: "#FF0000",
    }),
    // log information
    LogType: readonly({
        // https://vuetifyjs.com/en/styles/colors/#material-colors
        Initialization: readonly({ name: "Initialization", initials: "IN", color: "#00897B" }),  // teal darken-1
        SetQubitError: readonly({ name: "SetQubitError", initials: "SE", color: "#E53935" }),  // red darken-1
    }),
})

function make_log_element(log_type, obj) {
    let full_message = `unhandled log type: ${log_type.name}`
    let initials = log_type.initials
    let color = log_type.color
    if (log_type === CONST.LogType.Initialization) {
        full_message = `initialize data qubit (${obj.i}, ${obj.j})`
    } else if (log_type === CONST.LogType.SetQubitError) {
        full_message = `set qubit error "${obj.error}"`
        initials = obj.error
    } else {
        console.error(full_message)
        console.error(obj)
        initials = "??"
        color = "#D50000"  // red accent-4
    }
    return {
        log_type: log_type,
        color,
        full_message,
        initials,
        obj_str: JSON.stringify(obj),
    }
}

Vue.component('data-qubit', {
    template: '#data-qubit',
    model: {
        prop: 'qubit',
        event: 'qubit_changed'
    },
    props: {
        qubit: {
            type: Object,
        },
    },
    data() {
        return {
            CONST: CONST,
        }
    },
    computed: {
        error_color() {
            if (this.qubit.error == CONST.ErrorType.I) return CONST.Colors.I
            if (this.qubit.error == CONST.ErrorType.X) return CONST.Colors.X
            if (this.qubit.error == CONST.ErrorType.Z) return CONST.Colors.Z
            if (this.qubit.error == CONST.ErrorType.Y) return CONST.Colors.Y
        },
        error_text() {
            if (this.qubit.error == CONST.ErrorType.I) return "I"
            if (this.qubit.error == CONST.ErrorType.X) return "X"
            if (this.qubit.error == CONST.ErrorType.Z) return "Z"
            if (this.qubit.error == CONST.ErrorType.Y) return "Y"
        },
    },
    methods: {
        select_self(event) {
            this.$emit('select-qubit', [this.qubit.i, this.qubit.j])
            event.stopPropagation()
        },
        change_error(event) {
            if (this.qubit.error == CONST.ErrorType.I) this.qubit.error = CONST.ErrorType.X
            else if (this.qubit.error == CONST.ErrorType.X) this.qubit.error = CONST.ErrorType.Z
            else if (this.qubit.error == CONST.ErrorType.Z) this.qubit.error = CONST.ErrorType.Y
            else if (this.qubit.error == CONST.ErrorType.Y) this.qubit.error = CONST.ErrorType.I
            this.qubit.log.push(make_log_element(CONST.LogType.SetQubitError, { i: this.qubit.i, j: this.qubit.j, error: this.qubit.error }))
            this.$emit('error-changed')
            event.stopPropagation()
        },
    },
})

Vue.component('stabilizer-qubit', {
    template: '#stabilizer-qubit',
    model: {
        prop: 'qubit',
        event: 'qubit_changed'
    },
    props: {
        qubit: {
            type: Object,
        },
    },
    data() {
        return {
            CONST: CONST,
        }
    },
    methods: {
        select_self(event) {
            this.$emit('select-qubit', [this.qubit.i, this.qubit.j])
            event.stopPropagation()
        },
    },
})

var $app = new Vue({
    el : "#app",
    vuetify: new Vuetify(),
    data() {
        return {
            // standard planar code
            L: 3,  // code distance
            L_input: 3,  // user input L
            L_max: 10,  // maximum value of L
            L_input_rules: [v => {
                const L = parseInt(v)
                if (!(L >= 2)) { return "code distance must be in range [2, +∞)" }
                if (L > this.L_max) return "large code distance may have GUI render performance problem. to increase the maximum code distance, run `$app.L_max = 20` in console"
                this.L = L
                return true
            }],
            qubits: [],  // generated by `refresh_qubits`

            // display related
            window_width: window.innerWidth,
            window_height: window.innerHeight,
            CONST: CONST,
            selecting: null,  // or [i, j]
        }
    },
    computed: {
        log_items () {
            if (this.selecting == null) return []
            const [i, j] = this.selecting
            return this.qubits[i][j].log
        },
        square_max_width() {
            return this.window_width - 480
        },
        square_height() {
            if (this.square_max_width < this.window_height) return this.square_max_width
            return this.window_height
        },
        square_left() {
            if (this.square_max_width < this.window_height) return 0
            return (this.square_max_width - this.window_height) / 2
        },
        square_top() {
            if (this.square_max_width < this.window_height) return (this.window_height - this.square_max_width) / 2
            return 0
        },
        qubit_interval() {
            return this.square_height / (2 * this.L - 1)
        },
        qubit_bias() {
            return this.qubit_interval / 2 - CONST.QubitDivWidth / 2
        },
        qubit_scale() {
            return CONST.QubitWidthRatio * this.qubit_interval / 200
        },
    },
    mounted() {
        this.refresh_qubits()
        // do not update element size on touch screen devices, so that they can scroll well
        const update_resize = !('ontouchstart' in document.documentElement)
        if (update_resize) {
            window.addEventListener('resize', (() => {
                this.window_width = window.innerWidth
                this.window_height = window.innerHeight
            }).bind(this))
        }
    },
    methods: {
        refresh_qubits() {
            let qubits = []
            for (let i=0; i < 2 * this.L - 1; ++i) {
                let row = []
                for (let j=0; j < 2 * this.L - 1; ++j) {
                    const is_data_qubit = (i + j) % 2 == 0
                    const qubit_type = is_data_qubit ? CONST.QubitType.Data : (i % 2 == 0 ? CONST.QubitType.StabZ : CONST.QubitType.StabX)
                    let log = []
                    if (is_data_qubit) {
                        log.push(make_log_element(CONST.LogType.Initialization, { i, j, }))
                    }
                    let qubit = {
                        i, j,
                        qubit_type,
                        sub_scale: is_data_qubit ? 0.8 : 1,  // used to control relative size
                        selected: false,
                        error: CONST.ErrorType.I,  // no error when initialized
                        measurement: false,  // measurement result of XXXX or ZZZZ
                        mailbox: [],  // naive implementation of mailbox (because query is not efficient)
                        log,  // debug logs
                    }
                    row.push(qubit)
                }
                qubits.push(row)
            }
            this.qubits = qubits
            this.selecting = null
        },
        view_log(item) {
            console.log(item.log_type.name)
            console.log(JSON.parse(item.obj_str))  // create a copy object each time
        },
        select_qubit(info) {
            if (this.selecting != null) {
                const [i, j] = this.selecting
                this.qubits[i][j].selected = false
            }
            if (info == null) {  // deselect
                this.selecting = null
                return
            }
            const [i, j] = info
            this.qubits[i][j].selected = true
            this.selecting = [i, j]
        },
        error_changed() {  // recompute the stabilizer errors
            for (let i=0; i < this.qubits.length; ++i) {
                for (let j=0; j < this.qubits[i].length; ++j) {
                    let qubit = this.qubits[i][j]
                    if (qubit.qubit_type == CONST.QubitType.StabZ || qubit.qubit_type == CONST.QubitType.StabX) {
                        let error_count = 0
                        for (let [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                            const ti = i + di
                            if (ti < 0 || ti >= this.qubits.length) continue
                            const tj = j + dj
                            if (tj < 0 || tj >= this.qubits[ti].length) continue
                            const target_qubit = this.qubits[ti][tj]
                            if (qubit.qubit_type == CONST.QubitType.StabZ) {  // Z stabilizer detects X errors
                                if (target_qubit.error == CONST.ErrorType.X || target_qubit.error == CONST.ErrorType.Y) {
                                    error_count += 1
                                }
                            }
                            if (qubit.qubit_type == CONST.QubitType.StabX) {  // X stabilizer detects Z errors
                                if (target_qubit.error == CONST.ErrorType.Z || target_qubit.error == CONST.ErrorType.Y) {
                                    error_count += 1
                                }
                            }
                        }
                        qubit.measurement = error_count % 2 == 1
                    }
                }
            }
        },
    },
    watch: {
        L() {
            this.refresh_qubits()
        },
    },
})

</script>

<style>

body {
    /* background: blue; */
    margin: 0;
}

.square-qubits {
    position: fixed;
    /* background: blue; */
}

.control-panel {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	width: 460px;
	overflow: auto;
    padding: 10px;
    /* background: yellow; */
}

.qubit-div {
    width: 200px;  /* QubitDivWidth */
    height: 200px;  /* QubitDivWidth */
    transform-origin: center center;
    text-align: center;
}

.stabilizer-qubit-div-Z {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    transform-origin: center center;
    transform: scale(1);
    transition: transform .3s, box-shadow .3s;
}

.stabilizer-qubit-div-Z-no-error {
    /* THREE.Color( 0, 0.75, 1 ) */
    background: radial-gradient(circle at 100px 30px, #00BFFF, #005F7F);
    /* background: #00BFFF; */
}

.stabilizer-qubit-div-Z-with-error {
    background: radial-gradient(circle at 100px 30px, #00BFFF, red);
    /* background: red; */
}

.stabilizer-qubit-div-Z:hover {
    box-shadow: 0px 0px 50px #00BFFF;
    transform: scale(1.1);
}

.stabilizer-qubit-div-X {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    transform-origin: center center;
    transform: scale(1);
    transition: transform .3s, box-shadow .3s;
}

.stabilizer-qubit-div-X-no-error {
    /* THREE.Color( 0, 0.8, 0 ) */
    background: radial-gradient(circle at 100px 30px, #00CC00, #006600);
    /* background: #00CC00; */
}

.stabilizer-qubit-div-X-with-error {
    background: radial-gradient(circle at 100px 30px, #00CC00, red);
    /* background: red; */
}

.stabilizer-qubit-div-X:hover {
    box-shadow: 0px 0px 50px #00CC00;
    transform: scale(1.1);
}

.data-qubit-div {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    /* THREE.Color( 1, 0.65, 0 ) */
    background: radial-gradient(circle at 100px 30px, #FFA500, #7F5200);
    /* background: #FFA500; */
    transform-origin: center center;
    transform: scale(1);
    transition: transform .3s, box-shadow .3s;
}

.data-qubit-div:hover {
    box-shadow: 0px 0px 50px #FFA500;
    transform: scale(1.1);
}

.qubit-selected {
    transform: scale(1.1);
    box-shadow: 0px 0px 50px 20px yellow;
}

.qubit-div h1 {
    font-size: 50px;
    margin: 0;
}

.qubits-row {
    position: absolute;
}

.qubits-container {
    position: absolute;
    width: 200px;  /* QubitDivWidth */
    height: 200px;  /* QubitDivWidth */
    transform-origin: center center;
}

.noselect {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.no-scrollbar::-webkit-scrollbar {
	width: 0;
}

</style>

</body>
</html>
