<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Offer Decoder</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
<script src="https://unpkg.com/dayjs"></script>

<div id="app">
    <v-app>
        <div class="square-qubits" :style="{ 'height': square_height + 'px', 'width': square_height + 'px', 'left': square_left + 'px', 'top': square_top + 'px' }"
                @click="select_qubit(null)">
            <div v-for="(row, row_index) of qubits" v-bind:key="row_index" class="qubits-row" :style="{ 'top': (qubit_bias + row_index * qubit_interval) + 'px' }">
                <div v-for="(qubit, index) of row" v-bind:key="index" class="qubits-container"
                        :style="{ 'left': (qubit_bias + index * qubit_interval) + 'px', 'transform': `scale(${qubit_scale})` }">
                    <data-qubit v-if="qubit.qubit_type == CONST.QubitType.Data" v-model="row[index]" @select-qubit="select_qubit"
                        @error-changed="error_changed"></data-qubit>
                    <stabilizer-qubit v-if="qubit.qubit_type != CONST.QubitType.Data" v-model="row[index]" @select-qubit="select_qubit"></stabilizer-qubit>
                </div>
            </div>
        </div>
        <div class="control-panel no-scrollbar">
            <h1>Offer Decoder Testbed</h1>
            <p>Offer Decoder is a fully distributed topological code decoder. Every stabilizer as a decoder unit runs in parallel. In bounded time, the whole system converges to a stable state which is the error matching with the highest probability. The key idea is that matched pairs can work as "broker" and associate with unmatched stabilizers to optimize overall probability.</p>
            <p style="color: lightblue;">This page aims at helping us understand how it works and try out different strategies.</p>
            <v-text-field outlined label="Code Distance" type="number" v-model="L_input" :rules="L_input_rules" hide-details="auto"></v-text-field>
            <div style="margin-top: 10px;">
                <h2>Actions</h2>
                <v-btn color="green lighten-4" block @click="default_single_round" class="has-margin">default single round</v-btn>
                <div style="text-justify: space-around; text-align: center;">
                    <v-btn color="pink lighten-4" elevation="3" small @click="all_node_execute()" class="has-margin">node execute</v-btn>
                    <v-btn color="blue lighten-4" elevation="3" small @click="all_resend_offer()" class="has-margin">resend offer</v-btn>
                    <v-btn color="lime lighten-4" elevation="3" small @click="all_outqueue_send()" class="has-margin">outqueue send</v-btn>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <h2>Conditional Select</h2>
                <v-btn color="blue-grey lighten-4" block @click="select_none" class="has-margin">clear selection</v-btn>
                <div style="text-justify: space-around; text-align: center;">
                    <v-btn color="deep-orange lighten-4" elevation="3" small @click="select_has_offer_from_focused" class="has-margin">has offer from focused</v-btn>
                </div>
            </div>
            <div v-if="selecting != null" style="margin-top: 10px;">
                <h2>Focus: {{ `(${selecting[0]}, ${selecting[1]})`}} ({{ selecting[0] + selecting[1] % 2 == 0 ? "data qubit" : "stabilizer" }})</h2>
                <v-card elevation="5" width="440" class="mx-auto">
                    <v-virtual-scroll :items="log_items" :item-height="50" height="500">
                        <template v-slot:default="{ item }">
                            <v-list-item>
                                <v-list-item-avatar>
                                    <v-avatar :color="item.color" size="56" class="white--text">{{ item.initials }}</v-avatar>
                                </v-list-item-avatar>
                                <v-list-item-content>
                                    <v-list-item-title>{{ item.full_message }}</v-list-item-title>
                                </v-list-item-content>
                                <v-list-item-action>
                                    <v-btn depressed small @click="view_log(item)">View<v-icon color="orange darken-4" right>mdi-open-in-new</v-icon></v-btn>
                                </v-list-item-action>
                            </v-list-item>
                        </template>
                    </v-virtual-scroll>
                </v-card>
            </div>
        </div>
    </v-app>
</div>

<template id="data-qubit">
    <div class="qubit-div" :style="{ 'transform': `scale(${qubit.sub_scale})` }">
        <div class="data-qubit-div" :class="{ 'qubit-selected': qubit.selected }" @click="select_self">
            <h1 class="noselect">data</h1>
            <v-btn fab :width="120" :height="120" style="font-size: 100px;" :color="error_color" @click="change_error">{{ error_text }}</v-btn>
        </div>
    </div>
</template>

<template id="stabilizer-qubit">
    <div class="qubit-div" :style="{ 'transform': `scale(${qubit.sub_scale})` }">
        <div :class="{ 'stabilizer-qubit-div-Z': qubit.qubit_type == CONST.QubitType.StabZ, 'stabilizer-qubit-div-X': qubit.qubit_type == CONST.QubitType.StabX, 'qubit-selected': qubit.selected, 'stabilizer-qubit-div-X-no-error': qubit.qubit_type == CONST.QubitType.StabX && !qubit.measurement, 'stabilizer-qubit-div-X-with-error': qubit.qubit_type == CONST.QubitType.StabX && qubit.measurement, 'stabilizer-qubit-div-Z-no-error': qubit.qubit_type == CONST.QubitType.StabZ && !qubit.measurement, 'stabilizer-qubit-div-Z-with-error': qubit.qubit_type == CONST.QubitType.StabZ && qubit.measurement }"
                @click="select_self">
            <h1 class="noselect">{{ qubit.qubit_type == CONST.QubitType.StabZ ? "Z" : "X" }}</h1>
        </div>
    </div>
</template>

<!-- Vue.js -->
<script>

// use this function to restriction modification to constants
function readonly(target, keys) {
    var _cloned = {}
    function makeReadOnlyProperty(cloned, obj, prop) {
        Object.defineProperty(cloned, prop, {
            set: function() {
                throw {
                    name: 'UnableRewriteException',
                    message: 'original cannot be rewrite'
                }
            },
            get: function() {
                return obj[prop]
            },
            enumerable: true
        })
    }
    for (var prop in target) {
        makeReadOnlyProperty(_cloned, target, prop)
    }
    return _cloned
}

// allow user to override options, and alert those unrecognized options
function apply_override_options(default_options, override_options) {
    for (let key in override_options) {
        if (!(key in default_options)) {
            console.error(`unknown option "${key}", please check available options for this function`)
        }
    }
    Object.assign(default_options, override_options)
    return default_options
}

const CONST = readonly({
    QubitType: readonly({
        Data: "Data",
        StabZ: "StabZ",
        StabX: "StabX",
    }),
    ErrorType: readonly({
        I: "I",
        X: "X",
        Z: "Z",
        Y: "Y",
    }),
    // display related
    QubitDivWidth: 200,  // px
    QubitWidthRatio: 0.9,
    Colors: readonly({
        I: "#FFFFFF",
        X: "#00CC00",
        Z: "#00BFFF",
        Y: "#FF0000",
    }),
    // log information
    LogType: readonly({
        // https://vuetifyjs.com/en/styles/colors/#material-colors
        Initialization: readonly({ name: "Initialization", initials: "IN", color: "#00897B" }),  // teal darken-1
        SetQubitError: readonly({ name: "SetQubitError", initials: "SE", color: "#E53935" }),  // red darken-1
        UpdateMeasurement: readonly({ name: "UpdateMeasurement", initials: "UM", color: "#6D4C41" }),  // brown darken-1
        SendMessage: readonly({ name: "SendMessage", initials: "SM", color: "#039BE5" }),  // light-blue darken-1
    }),
    // node states
    NodeState: readonly({
        NoError: "NoError",  // no error syndrome at this node. only work as offer repeator
        SentOffer: "OfferSent",  // offer sent and waiting for responses
        SentContract: "SentContract",  // contract sent and waiting for responses
        WaitingContract: "WaitingContract",  // take offer and reply, then waiting for contract. 
        Matched: "Matched",
    }),
    // message type
    MessageType: readonly({
        MatchOffer: "MatchOffer",  // only sent out by unmatched pairs
        AugmentOffer: "AugmentOffer",  // only sent out by matched pairs to find augmenting loop
    }),
})

function make_log_element(log_type, obj) {
    let full_message = `unhandled log type: ${log_type.name}, please update "make_log_element" function`
    let initials = log_type.initials
    let color = log_type.color
    if (log_type === CONST.LogType.Initialization) {
        full_message = `initialize data qubit (${obj.i}, ${obj.j})`
    } else if (log_type === CONST.LogType.SetQubitError) {
        full_message = `set qubit error "${obj.error}"`
        initials = obj.error
    } else if (log_type === CONST.LogType.UpdateMeasurement) {
        full_message = `update measurement as "${obj.measurement}"`
    } else if (log_type === CONST.LogType.SendMessage) {
        full_message = `send message to (${obj.i}, ${obj.j})`
    } else {
        console.error(full_message)
        console.error(obj)
        initials = "??"
        color = "#D50000"  // red accent-4
    }
    return {
        log_type: log_type,
        color,
        full_message,
        initials,
        obj_str: JSON.stringify(obj),
        create_time: new Date(),
    }
}

Vue.component('data-qubit', {
    template: '#data-qubit',
    model: {
        prop: 'qubit',
        event: 'qubit_changed'
    },
    props: {
        qubit: {
            type: Object,
        },
    },
    data() {
        return {
            CONST: CONST,
        }
    },
    computed: {
        error_color() {
            if (this.qubit.error == CONST.ErrorType.I) return CONST.Colors.I
            if (this.qubit.error == CONST.ErrorType.X) return CONST.Colors.X
            if (this.qubit.error == CONST.ErrorType.Z) return CONST.Colors.Z
            if (this.qubit.error == CONST.ErrorType.Y) return CONST.Colors.Y
        },
        error_text() {
            if (this.qubit.error == CONST.ErrorType.I) return "I"
            if (this.qubit.error == CONST.ErrorType.X) return "X"
            if (this.qubit.error == CONST.ErrorType.Z) return "Z"
            if (this.qubit.error == CONST.ErrorType.Y) return "Y"
        },
    },
    methods: {
        select_self(event) {
            this.$emit('select-qubit', [this.qubit.i, this.qubit.j])
            event.stopPropagation()
        },
        change_error(event) {
            if (this.qubit.error == CONST.ErrorType.I) this.qubit.error = CONST.ErrorType.X
            else if (this.qubit.error == CONST.ErrorType.X) this.qubit.error = CONST.ErrorType.Z
            else if (this.qubit.error == CONST.ErrorType.Z) this.qubit.error = CONST.ErrorType.Y
            else if (this.qubit.error == CONST.ErrorType.Y) this.qubit.error = CONST.ErrorType.I
            this.qubit.log.push(make_log_element(CONST.LogType.SetQubitError, { i: this.qubit.i, j: this.qubit.j, error: this.qubit.error }))
            this.$emit('error-changed')
            event.stopPropagation()
        },
    },
})

Vue.component('stabilizer-qubit', {
    template: '#stabilizer-qubit',
    model: {
        prop: 'qubit',
        event: 'qubit_changed'
    },
    props: {
        qubit: {
            type: Object,
        },
    },
    data() {
        return {
            CONST: CONST,
        }
    },
    methods: {
        select_self(event) {
            this.$emit('select-qubit', [this.qubit.i, this.qubit.j])
            event.stopPropagation()
        },
    },
})

var $app = new Vue({
    el : "#app",
    vuetify: new Vuetify(),
    data() {
        return {
            // standard planar code
            L: 3,  // code distance
            L_input: 3,  // user input L
            L_max: 10,  // maximum value of L
            L_input_rules: [v => {
                const L = parseInt(v)
                if (!(L >= 2)) { return "code distance must be in range [2, +∞)" }
                if (L > this.L_max) return "large code distance may have GUI render performance problem. to increase the maximum code distance, run `$app.L_max = 20` in console"
                this.L = L
                return true
            }],
            qubits: [],  // generated by `refresh_qubits`

            // display related
            window_width: window.innerWidth,
            window_height: window.innerHeight,
            CONST: CONST,
            selecting: null,  // or [i, j]
        }
    },
    computed: {
        log_items () {
            if (this.selecting == null) return []
            const [i, j] = this.selecting
            return this.qubits[i][j].log
        },
        square_max_width() {
            return this.window_width - 480
        },
        square_height() {
            if (this.square_max_width < this.window_height) return this.square_max_width
            return this.window_height
        },
        square_left() {
            if (this.square_max_width < this.window_height) return 0
            return (this.square_max_width - this.window_height) / 2
        },
        square_top() {
            if (this.square_max_width < this.window_height) return (this.window_height - this.square_max_width) / 2
            return 0
        },
        qubit_interval() {
            return this.square_height / (2 * this.L - 1)
        },
        qubit_bias() {
            return this.qubit_interval / 2 - CONST.QubitDivWidth / 2
        },
        qubit_scale() {
            return CONST.QubitWidthRatio * this.qubit_interval / 200
        },
    },
    mounted() {
        this.refresh_qubits()
        // do not update element size on touch screen devices, so that they can scroll well
        const update_resize = !('ontouchstart' in document.documentElement)
        if (update_resize) {
            window.addEventListener('resize', (() => {
                this.window_width = window.innerWidth
                this.window_height = window.innerHeight
            }).bind(this))
        }
    },
    methods: {
        refresh_qubits() {
            let qubits = []
            for (let i=0; i < 2 * this.L - 1; ++i) {
                let row = []
                for (let j=0; j < 2 * this.L - 1; ++j) {
                    const is_data_qubit = (i + j) % 2 == 0
                    const qubit_type = is_data_qubit ? CONST.QubitType.Data : (i % 2 == 0 ? CONST.QubitType.StabZ : CONST.QubitType.StabX)
                    let log = []
                    if (is_data_qubit) {
                        log.push(make_log_element(CONST.LogType.Initialization, { i, j, }))
                    } else {
                        log.push(make_log_element(CONST.LogType.UpdateMeasurement, { i, j, measurement: false }))
                    }
                    let qubit = {
                        i, j,
                        qubit_type,
                        sub_scale: is_data_qubit ? 0.8 : 1,  // used to control relative size
                        selected: false,
                        error: CONST.ErrorType.I,  // no error when initialized
                        measurement: false,  // measurement result of XXXX or ZZZZ
                        mailbox: [],  // naive implementation of mailbox (because query is not efficient)
                        outqueue: [],  // { target: [i, j], message } where message is then pushed into the target's mailbox
                        log,  // debug logs
                    }
                    if (!is_data_qubit) {
                        // attributes for nodes only
                        Object.assign(qubit, {
                            active_offer: null,  // { timestamp }
                            brokered_offers: {},  // JSON.stringify([i, j]): { source, last, timestamp }
                            state: CONST.NodeState.NoError,
                        })
                        // methods for nodes only
                        qubit.node_execute = ((override_options = {}) => {
                            // override default options
                            const options = apply_override_options({
                                only_accept_offer_from_smaller_node: true,  // to avoid conflicting execution of 2 nodes, in which case they'll never be matched
                                only_handle_one_message: false,  // only handle one message to debug
                            }, override_options)
                            // sanity check, we don't handle the logic if some measurement error disappears (have to break the matched pairs)
                            if (qubit.measurement == false && qubit.state != CONST.NodeState.NoError) {
                                console.error(`qubit (${i},${j}) measurement changed from "true" to "false", which is not supported yet`)
                            }
                            // read message
                            while (qubit.mailbox.length > 0) {
                                const message = qubit.mailbox.shift()  // take the first message in mailbox
                                console.error(`drop unknown message with type: "${message.type}"`)
                                console.error(message)
                                if (options.only_handle_one_message) break  // only handle one message
                            }
                        }).bind(this)
                        qubit.resend_offer = ((override_options = {}) => {
                            // override default options
                            const options = apply_override_options({

                            }, override_options)
                            // normal node never sends offer
                            if (qubit.measurement == false) return
                            // if the state of this qubit is matched, then the offer targets only self
                            if (qubit.state == CONST.NodeState.Matched) {
                                
                            } else if (qubit.state == CONST.NodeState.NoError || qubit.state == CONST.NodeState.SentOffer) {
                                for (let [ti, tj] of [[i-2, j], [i+2, j], [i, j-2], [i, j+2]]) if (this.is_valid_i_j(ti, tj)) {
                                    qubit.outqueue.push({
                                        target: [ti, tj],
                                        message: {
                                            type: CONST.MessageType.MatchOffer,
                                            source: [i, j],
                                            broker: [i, j],  // if broker == source then there is no broker
                                        },
                                    })
                                }
                                qubit.state = CONST.NodeState.SentOffer  // offer sent and waiting for replies
                            } else {
                                // TODO: what if in other states? during contract making? simply do nothing at this moment
                            }
                        }).bind(this)
                        qubit.outqueue_send = ((override_options = {}) => {
                            // override default options
                            const options = apply_override_options({

                            }, override_options)
                            // send messages from outqueue
                            while (qubit.outqueue.length > 0) {
                                const out = qubit.outqueue.shift()
                                const [ti, tj] = out.target
                                if (this.is_valid_i_j(ti, tj)) {
                                    const message = out.message
                                    this.qubits[ti][tj].mailbox.push(message)
                                    qubit.log.push(make_log_element(CONST.LogType.SendMessage, { i: ti, j: tj, message }))
                                } else {
                                    console.error(`(${i},${j})'s outqueue message has invalid target address: (${ti},${tj})`)
                                    console.log(out)
                                }
                            }
                        }).bind(this)
                    }
                    row.push(qubit)
                }
                qubits.push(row)
            }
            this.qubits = qubits
            this.selecting = null
        },
        is_valid_i_j(i, j) {
            if (i < 0 || i >= this.L * 2 - 1) return false
            if (j < 0 || j >= this.L * 2 - 1) return false
            return true
        },
        view_log(item) {
            console.log(`[${dayjs(item.create_time).format("HH:mm:ss.SSS")}] ${item.log_type.name}: ${item.full_message}`)
            console.log(JSON.parse(item.obj_str))  // create a copy object each time
        },
        select_qubit(info) {
            if (this.selecting != null) {
                const [i, j] = this.selecting
                this.qubits[i][j].selected = false
            }
            if (info == null) {  // deselect
                this.selecting = null
                return
            }
            const [i, j] = info
            this.qubits[i][j].selected = true
            this.selecting = [i, j]
        },
        error_changed() {  // recompute the stabilizer errors
            for (let i=0; i < this.qubits.length; ++i) {
                for (let j=0; j < this.qubits[i].length; ++j) {
                    let qubit = this.qubits[i][j]
                    if (qubit.qubit_type == CONST.QubitType.StabZ || qubit.qubit_type == CONST.QubitType.StabX) {
                        let error_count = 0
                        for (let [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                            const ti = i + di
                            if (ti < 0 || ti >= this.qubits.length) continue
                            const tj = j + dj
                            if (tj < 0 || tj >= this.qubits[ti].length) continue
                            const target_qubit = this.qubits[ti][tj]
                            if (qubit.qubit_type == CONST.QubitType.StabZ) {  // Z stabilizer detects X errors
                                if (target_qubit.error == CONST.ErrorType.X || target_qubit.error == CONST.ErrorType.Y) {
                                    error_count += 1
                                }
                            }
                            if (qubit.qubit_type == CONST.QubitType.StabX) {  // X stabilizer detects Z errors
                                if (target_qubit.error == CONST.ErrorType.Z || target_qubit.error == CONST.ErrorType.Y) {
                                    error_count += 1
                                }
                            }
                        }
                        const measurement = error_count % 2 == 1
                        if (qubit.measurement != measurement) {
                            qubit.log.push(make_log_element(CONST.LogType.UpdateMeasurement, { i, j, measurement }))
                        }
                        qubit.measurement = measurement
                    }
                }
            }
        },
        for_each_qubit(func) {
            for (let i=0; i < this.qubits.length; ++i) {
                for (let j=0; j < this.qubits[i].length; ++j) {
                    let qubit = this.qubits[i][j]
                    func(i, j, qubit)
                }
            }
        },
        all_node_execute(override_options = {}) {
            this.for_each_qubit((i, j, qubit) => {
                if (qubit.node_execute) qubit.node_execute(override_options)
            })
        },
        all_resend_offer(override_options = {}) {
            this.for_each_qubit((i, j, qubit) => {
                if (qubit.resend_offer) qubit.resend_offer(override_options)
            })
        },
        all_outqueue_send(override_options = {}) {
            this.for_each_qubit((i, j, qubit) => {
                if (qubit.outqueue_send) qubit.outqueue_send(override_options)
            })
        },
        default_single_round() {
            this.for_each_qubit((i, j, qubit) => {
                // only resend offer if it has not sent any offer yet
                if (qubit.measurement == true && qubit.state == CONST.NodeState.NoError) {
                    if (qubit.resend_offer) qubit.resend_offer()
                }
            })
            this.all_node_execute()
            this.all_outqueue_send()
        },
        select_none() {
            
        },
        select_has_offer_from_focused() {

        },
    },
    watch: {
        L() {
            this.refresh_qubits()
        },
    },
})

</script>

<style>

body {
    /* background: blue; */
    margin: 0;
}

.square-qubits {
    position: fixed;
    /* background: blue; */
}

.control-panel {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	width: 460px;
	overflow: auto;
    padding: 10px;
    /* background: yellow; */
}

.qubit-div {
    width: 200px;  /* QubitDivWidth */
    height: 200px;  /* QubitDivWidth */
    transform-origin: center center;
    text-align: center;
}

.stabilizer-qubit-div-Z {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    transform-origin: center center;
    transform: scale(1);
    transition: transform .3s, box-shadow .3s;
}

.stabilizer-qubit-div-Z-no-error {
    /* THREE.Color( 0, 0.75, 1 ) */
    background: radial-gradient(circle at 100px 30px, #00BFFF, #005F7F);
    /* background: #00BFFF; */
}

.stabilizer-qubit-div-Z-with-error {
    background: radial-gradient(circle at 100px 30px, #00BFFF, red);
    /* background: red; */
}

.stabilizer-qubit-div-Z:hover {
    box-shadow: 0px 0px 50px #00BFFF;
    transform: scale(1.1);
}

.stabilizer-qubit-div-X {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    transform-origin: center center;
    transform: scale(1);
    transition: transform .3s, box-shadow .3s;
}

.stabilizer-qubit-div-X-no-error {
    /* THREE.Color( 0, 0.8, 0 ) */
    background: radial-gradient(circle at 100px 30px, #00CC00, #006600);
    /* background: #00CC00; */
}

.stabilizer-qubit-div-X-with-error {
    background: radial-gradient(circle at 100px 30px, #00CC00, red);
    /* background: red; */
}

.stabilizer-qubit-div-X:hover {
    box-shadow: 0px 0px 50px #00CC00;
    transform: scale(1.1);
}

.data-qubit-div {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    /* THREE.Color( 1, 0.65, 0 ) */
    background: radial-gradient(circle at 100px 30px, #FFA500, #7F5200);
    /* background: #FFA500; */
    transform-origin: center center;
    transform: scale(1);
    transition: transform .3s, box-shadow .3s;
}

.data-qubit-div:hover {
    box-shadow: 0px 0px 50px #FFA500;
    transform: scale(1.1);
}

.qubit-selected {
    transform: scale(1.1);
    box-shadow: 0px 0px 50px 20px yellow;
}

.qubit-div h1 {
    font-size: 50px;
    margin: 0;
}

.qubits-row {
    position: absolute;
}

.qubits-container {
    position: absolute;
    width: 200px;  /* QubitDivWidth */
    height: 200px;  /* QubitDivWidth */
    transform-origin: center center;
}

.noselect {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.no-scrollbar::-webkit-scrollbar {
	width: 0;
}

.has-margin {
    margin-top: 10px;
    margin-left: 5px;
}

</style>

</body>
</html>
