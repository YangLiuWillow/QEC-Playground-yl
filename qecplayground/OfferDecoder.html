<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offer Decoder</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<div id="app">
    <div class="square-qubits" :style="{ 'height': square_height + 'px', 'width': square_height + 'px', 'left': square_left + 'px', 'top': square_top + 'px' }"
            @click="select_qubit(null)">
        <div v-for="(row, row_index) of qubits" v-bind:key="row_index" class="qubits-row" :style="{ 'top': (qubit_bias + row_index * qubit_interval) + 'px' }">
            <div v-for="(qubit, index) of row" v-bind:key="index" class="qubits-container"
                    :style="{ 'left': (qubit_bias + index * qubit_interval) + 'px', 'transform': `scale(${qubit_scale})` }">
                <data-qubit v-if="qubit.qubit_type == CONST.QubitType.Data" v-model="row[index]" @select-qubit="select_qubit"></data-qubit>
                <stabilizer-qubit v-if="qubit.qubit_type != CONST.QubitType.Data" v-model="row[index]" @select-qubit="select_qubit"></stabilizer-qubit>
            </div>
        </div>
    </div>
    <div class="control-panel no-scrollbar">

    </div>
</div>

<template id="data-qubit">
    <div class="qubit-div" :style="{ 'transform': `scale(${qubit.sub_scale})` }">
        <div class="data-qubit-div" :class="{ 'qubit-selected': qubit.selected }" @click="select_self">
            <h1 class="noselect">data</h1>
        </div>
    </div>
</template>

<template id="stabilizer-qubit">
    <div class="qubit-div" :style="{ 'transform': `scale(${qubit.sub_scale})` }">
        <div :class="{ 'stabilizer-qubit-div-Z': qubit.qubit_type == CONST.QubitType.StabZ, 'stabilizer-qubit-div-X': qubit.qubit_type == CONST.QubitType.StabX, 'qubit-selected': qubit.selected }"
                @click="select_self">
            <h1 class="noselect">{{ qubit.qubit_type == CONST.QubitType.StabZ ? "Z" : "X" }}</h1>
        </div>
    </div>
</template>

<!-- Vue.js -->
<script>

// use this function to restriction modification to constants
function readonly(target, keys) {
    var _cloned = {}
    function makeReadOnlyProperty(cloned, obj, prop) {
        Object.defineProperty(cloned, prop, {
            set: function() {
                throw {
                    name: 'UnableRewriteException',
                    message: 'original cannot be rewrite'
                }
            },
            get: function() {
                return obj[prop]
            },
            enumerable: true
        })
    }
    for (var prop in target) {
        makeReadOnlyProperty(_cloned, target, prop)
    }
    return _cloned
}

const CONST = readonly({
    QubitType: readonly({
        Data: "Data",
        StabZ: "StabZ",
        StabX: "StabX",
    }),
    // display related
    QubitDivWidth: 200,  // px
    QubitWidthRatio: 0.8,
})

Vue.component('data-qubit', {
    template: '#data-qubit',
    model: {
        prop: 'qubit',
        event: 'qubit_changed'
    },
    props: {
        qubit: {
            type: Object,
        },
    },
    data() {
        return {
            CONST: CONST,
        }
    },
    methods: {
        select_self(event) {
            this.$emit('select-qubit', [this.qubit.i, this.qubit.j])
            event.stopPropagation()
        },
    },
})

Vue.component('stabilizer-qubit', {
    template: '#stabilizer-qubit',
    model: {
        prop: 'qubit',
        event: 'qubit_changed'
    },
    props: {
        qubit: {
            type: Object,
        },
    },
    data() {
        return {
            CONST: CONST,
        }
    },
    methods: {
        select_self(event) {
            this.$emit('select-qubit', [this.qubit.i, this.qubit.j])
            event.stopPropagation()
        },
    },
})

var $app = new Vue({
    el : "#app",
    data() {
        return {
            // standard planar code
            L: 3,  // code distance
            qubits: [],  // generated by `refresh_qubits`

            // display related
            window_width: window.innerWidth,
            window_height: window.innerHeight,
            CONST: CONST,
            selecting: null,  // or [i, j]
        }
    },
    computed: {
        square_max_width() {
            return this.window_width - 480
        },
        square_height() {
            if (this.square_max_width < this.window_height) return this.square_max_width
            return this.window_height
        },
        square_left() {
            if (this.square_max_width < this.window_height) return 0
            return (this.square_max_width - this.window_height) / 2
        },
        square_top() {
            if (this.square_max_width < this.window_height) return (this.window_height - this.square_max_width) / 2
            return 0
        },
        qubit_interval() {
            return this.square_height / (2 * this.L - 1)
        },
        qubit_bias() {
            return this.qubit_interval / 2 - CONST.QubitDivWidth / 2
        },
        qubit_scale() {
            return CONST.QubitWidthRatio * this.qubit_interval / 200
        },
    },
    mounted() {
        this.refresh_qubits()
        // do not update element size on touch screen devices, so that they can scroll well
        const update_resize = !('ontouchstart' in document.documentElement)
        if (update_resize) {
            window.addEventListener('resize', (() => {
                this.window_width = window.innerWidth
                this.window_height = window.innerHeight
            }).bind(this))
        }
    },
    methods: {
        refresh_qubits() {
            let qubits = []
            for (let i=0; i < 2 * this.L - 1; ++i) {
                let row = []
                for (let j=0; j < 2 * this.L - 1; ++j) {
                    const is_data_qubit = (i + j) % 2 == 0
                    const qubit_type = is_data_qubit ? CONST.QubitType.Data : (i % 2 == 0 ? CONST.QubitType.StabZ : CONST.QubitType.StabX)
                    let qubit = {
                        i, j,
                        qubit_type,
                        sub_scale: is_data_qubit ? 0.6 : 1,  // used to control relative size
                        selected: false,
                    }
                    row.push(qubit)
                }
                qubits.push(row)
            }
            this.qubits = qubits
            this.selecting = null
        },
        select_qubit(info) {
            if (this.selecting != null) {
                const [i, j] = this.selecting
                this.qubits[i][j].selected = false
            }
            if (info == null) {  // deselect
                this.selecting = null
                return
            }
            const [i, j] = info
            this.qubits[i][j].selected = true
            this.selecting = [i, j]
        },
    },
    watch: {
        L() {
            this.refresh_qubits()
        },
    },
})

</script>

<style>

body {
    /* background: blue; */
    margin: 0;
}

.square-qubits {
    position: fixed;
    /* background: blue; */
}

.control-panel {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	width: 460px;
	overflow: auto;
    padding: 10px;
    background: yellow;
}

.qubit-div {
    width: 200px;  /* QubitDivWidth */
    height: 200px;  /* QubitDivWidth */
    transform-origin: center center;
    text-align: center;
}

.stabilizer-qubit-div-Z {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    /* THREE.Color( 0, 0.75, 1 ) */
    background: radial-gradient(circle at 100px 30px, #00BFFF, #005F7F);
    /* background: #00BFFF; */
    transform-origin: center center;
    transform: scale(1);
    transition: all .3s;
}

.stabilizer-qubit-div-Z:hover {
    box-shadow: 0px 0px 50px #00BFFF;
    transform: scale(1.1);
}

.stabilizer-qubit-div-X {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    /* THREE.Color( 0, 0.8, 0 ) */
    background: radial-gradient(circle at 100px 30px, #00CC00, #006600);
    /* background: #00CC00; */
    transform-origin: center center;
    transform: scale(1);
    transition: all .3s;
}

.stabilizer-qubit-div-X:hover {
    box-shadow: 0px 0px 50px #00CC00;
    transform: scale(1.1);
}

.data-qubit-div {
    width: 200px;
    height: 200px;
    border-radius: 100px;
    /* THREE.Color( 1, 0.65, 0 ) */
    background: radial-gradient(circle at 100px 30px, #FFA500, #7F5200);
    /* background: #FFA500; */
    transform-origin: center center;
    transform: scale(1);
    transition: all .3s;
}

.data-qubit-div:hover {
    box-shadow: 0px 0px 50px #FFA500;
    transform: scale(1.1);
}

.qubit-selected {
    transform: scale(1.1);
    position: relative;
}

.qubit-selected:before {
    content: "";
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: 100px;
    position: absolute;
    box-shadow: 0px 0px 50px 50px yellow;
}

.qubit-div h1 {
    font-size: 50px;
    margin: 0;
}

.qubits-row {
    position: absolute;
}

.qubits-container {
    position: absolute;
    width: 200px;  /* QubitDivWidth */
    height: 200px;  /* QubitDivWidth */
    transform-origin: center center;
}

.noselect {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

</style>

</body>
</html>
